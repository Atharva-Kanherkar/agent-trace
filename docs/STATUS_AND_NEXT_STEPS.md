# agent-trace Status and Next Steps

Updated: 2026-02-23

## What is already complete

## Core typed modules

1. `@agent-trace/schema`
   - Strict domain contracts (`EventEnvelope`, `AgentSessionTrace`, timeline, metrics).
   - Runtime validators with deterministic errors.
2. `@agent-trace/collector`
   - Typed ingest handler (`/health`, `/v1/hooks`, `/v1/hooks/stats`).
   - In-memory deduplication store.
   - Raw HTTP adapter and Node HTTP handler creator.
   - Collector service wrapper for accepted-event processing pipeline + processing health stats.
   - Envelope collector service composition with default transcript-ingestion wiring.
   - Transcript JSONL parser foundation (`parseTranscriptJsonl`) for Layer 3 ingestion.
   - Session-end transcript ingestion processor (`createTranscriptIngestionProcessor`) with sink integration.
   - OTEL export normalizer foundation (`normalizeOtelExport`) for Layer 1 event extraction.
   - OTEL gRPC receiver module (`startOtelGrpcReceiver`) with export processing stats.
   - Standalone collector server starter (`startStandaloneCollector`) wiring HTTP + OTEL receiver.
3. `@agent-trace/api`
   - Typed query handler (`/health`, `/v1/sessions`, `/v1/sessions/:id`, `/timeline`).
   - In-memory session repository.
   - Raw HTTP adapter and Node HTTP handler creator.
4. `@agent-trace/cli`
   - `init`, `status`, `hook-handler`.
   - Config file lifecycle in `~/.claude/agent-trace.json`.
   - Forward mode: `hook-handler --forward` posts to collector URL from config.
   - `init` generates Claude hook configuration artifact (`agent-trace-claude-hooks.json`).
   - `init` installs hook commands into Claude settings (`settings.local.json`) by default.
   - `status` reports both artifact presence and settings-hook installation state.
5. `@agent-trace/dashboard` (core only)
   - View-model mappers for sessions and timelines.
   - Cost and project summary analytics functions.
6. `@agent-trace/platform`
   - Migration manifest and migration-file validator.
   - Baseline ClickHouse and PostgreSQL SQL migrations.
   - Strict ClickHouse `agent_events` row mapper and writer abstraction.
   - Strict PostgreSQL writers for `sessions`, `commits`, and `instance_settings`.
   - Real DB client adapters:
     - ClickHouse adapter using `@clickhouse/client`
     - PostgreSQL adapter using `pg`
7. `@agent-trace/runtime`
   - In-memory runtime assembly for collector + api.
   - Process-level HTTP servers on `:8317` (collector) and `:8318` (api).
   - Runtime projector wiring from accepted events into session traces.
   - CLI forward integration coverage against runtime collector.
   - In-memory persistence pipeline wiring:
     - accepted events -> ClickHouse event writer
     - projected traces -> PostgreSQL session/commit writer
   - Pluggable runtime persistence (inject real DB-backed adapters).
   - DB-backed runtime composition factory with lifecycle-managed clients.
   - Runtime OTEL sink and startup wiring for OTEL gRPC receiver (`:4717`).

## Quality gates

Every module currently has:

1. Strict TypeScript typecheck.
2. Unit tests.
3. Manual smoke script.

Root commands pass for all implemented modules:

1. `npm run typecheck`
2. `npm run test:unit`
3. `npm run test:manual`

---

## What is left (ordered)

## Stage A: Runtime assembly (complete)

1. Actual process-level service binaries:
   - collector server process on `:8317`
   - api server process on `:8318`
2. End-to-end in-memory runtime wiring:
   - collector ingest -> session projection -> api query responses
3. CLI forward integration test path against runtime handlers.

Feature set complete after Stage A:

1. Local end-to-end demo flow without external DB.

## Stage B: Persistence and projection (in progress)

1. ClickHouse writer implementation:
   - Events writer for `agent_events` complete.
   - Session aggregate writers/materialized flow pending.
2. PostgreSQL writer implementation (sessions, commits, settings).
   - Core typed writer implementation complete.
   - In-memory collector wiring complete.
   - Real DB client adapter complete.
   - Runtime integration path for injected DB adapters complete.
3. Collector projection pipeline to update session traces as events arrive.
   - In-memory runtime projection + persistence orchestration complete.
   - DB-backed runtime composition complete.
   - Collector service wiring abstraction complete.
   - Production deployment composition (collector + api + db process setup) pending.

Feature set complete after Stage B:

1. Durable storage-backed observability in local environment.

## Stage C: Claude integration completion (complete)

1. Claude hook setup generated by CLI `init` in production format.
   - Base hook config artifact generation complete.
   - Direct Claude settings installation path complete.
2. OTEL ingest receiver path integration.
   - OTEL payload normalization logic complete.
   - gRPC receiver transport implementation complete.
   - Runtime startup wiring for `:4717` complete.
   - Standalone collector process wiring complete.
3. Transcript ingestion parser path.
   - Base parser implementation complete.
   - SessionEnd ingestion processor abstraction complete.
   - Default collector wiring for transcript ingestion path complete.

Feature set complete after Stage C:

1. Full three-layer Claude telemetry ingestion path.

## Stage D: Product surface completion

1. Real dashboard app (Next.js UI shell + API integration).
2. Docker Compose service graph (collector, api, dashboard, dbs).
3. Operational docs and startup scripts.

Feature set complete after Stage D:

1. Self-hosted, one-command local deployment with replay + analytics.

---

## How this will be used in practice

Target usage flow:

1. Operator starts local stack (`collector`, `api`, `dashboard`, storage).
2. Developer runs `agent-trace init` once.
3. Claude Code triggers hook events during sessions.
4. Hook events are transformed into typed envelopes by `hook-handler`.
5. Envelopes are forwarded to collector (`--forward`).
6. Collector validates/deduplicates/persists.
7. API serves session list, timeline, and metrics.
8. Dashboard renders replay and cost analytics.
